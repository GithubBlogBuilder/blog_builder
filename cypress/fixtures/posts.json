[
    {
        "name":"test name 1",
        "intro": "test intro 1",
        "content": "test content 1"
    },
    {
        "name":"intro empty test",
        "intro": "",
        "content": "test content 1"
    },
    {
        "name":"content empty test",
        "intro": "test intro 1",
        "content": ""
    },
    {    
        "name":"專案介紹",
        "intro": "這是複製此專案在github上的readme檔案而來的文章",
        "tag":"i, d, k",
        "content": "#Blog Builder\n\nThis is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).\n\n## Getting Started\n\nFirst, run the development server:\n\n```bash\nnpm run dev\n# or\nyarn dev\n# or\npnpm dev\n# or\nbun dev\n```\n\nOpen [http://localhost:3000](http://localhost:3000) with your browser to see the result.\n\nYou can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.\n\nThis project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.\n\n## Learn More\n\nTo learn more about Next.js, take a look at the following resources:\n\n- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.\n- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.\n\nYou can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!\n\n## Deploy on Vercel\n\nThe easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.\n\nCheck out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.\n\n## to run the test\n\ncheck dependency installed:\n\n```bash\nnpm install\n```\n\nrun test\n\n```bash\nnpm run cy:run\n```\n\ntest dev tool\n\n```bash\nnpm run cy:open\n```\n"
    },
    {
        "name": "latex語法測試",
        "intro": "這是由測試者hackmd筆記中複製而來的latex測試",
        "tag": "i, d, k",
        "content":"# PQC-Lattice based cryptography筆記\n\n## Lattice\n\n### Lattices defination\n\n- An n-dimensional lattice $\\mathcal L$ is an subset of $\\mathbb R^n$ that is both\n    1. additive subgroup: $0\\in \\mathcal L$, and $\\forall x, y\\in \\mathcal L, -x, x+y\\in \\mathcal L$\n    2. discrete: every $x \\in \\mathcal L$ has a neighbor in $\\mathbb R^n$ in which x is the only lattice point.\n\n- minimum distance of a lattice $\\mathcal L$\n    $$\\lambda_1(\\mathcal L):=\\min_{v\\in \\mathcal L \\backslash\\{0\\}}||v||.$$\n    $||\\cdot||$ denote the minimum euclidean norm, and $\\lambda_i(\\mathcal L)$ is the norm of $i$-th sortest linearly independent vector.\n    \n- quotient qroup $\\mathbb R^n/\\mathcal L$ of cosets\n    $$c+\\mathcal L = \\{c+v:v\\in\\mathcal L\\}, c\\in \\mathbb R^n$$\n    \n- fundamental domain of $\\mathcal L$ is a set $\\mathcal F\\subset \\mathbb R^n$ that \n    contain exactly one representative $\\bar c\\in (c+\\mathcal L)\\cap \\mathcal F$ in every coset $c+\\mathcal L$\n    (我的理解是找到一個保證任何平移後都會洽有一個晶格點落在其中的空間)\n    \n- Bases: every lattice $\\mathcal L$ always finitely generated as the integer linear combinations of some linearly independent $basis$ vector $B=\\{b_1, b_2, ..., b_k\\}:$\n    $$\\mathcal L = \\mathcal L(B):=B \\cdot \\mathbb Z^k=\\left\\{\\sum_{i=1}^kz_ib_i:z_i\\in \\mathbb Z\\right\\}$$\n    A lattice base $B$ is not unique: for any unimodular matrix $U\\in \\mathbb Z^{n\\times n}$(unimodular means having determinant $\\pm 1$), $B\\cdot U$ is also a basis of $\\mathcal L(B)$\n    \n- fundamental parallelpipeds:\n    for a lattice $\\mathcal L$ having a basis $B$, a commonly used fundamental domain is the origin-centered fundamental parallelepiped $\\mathcal P(B):=B\\cdot [-\\frac 1 2, \\frac 1 2)^n$, where coset $c+\\mathcal L$ has representative $c-B\\cdot \\lfloor B^{-1}\\cdot c\\rceil$. \n    proof.\n    lemma: $\\forall x\\in \\mathbb R^n, x-\\lfloor x\\rceil\\in [-\\frac 1 2, \\frac 1 2)^n$\n    $\\eqalign{\n    &c-B\\cdot \\lfloor B^{-1}\\cdot c\\rceil \\\\\n    =&B\\cdot (B^{-1}\\cdot c)-B\\cdot \\lfloor B^{-1}\\cdot c\\rceil\\\\\n    =&B\\cdot (B^{-1}\\cdot c-\\lfloor B^{-1}\\cdot c\\rceil)\\\\\n    \\in &B\\cdot {[-\\frac 1 2, \\frac 1 2)}^n\n    }$\n    \n- dual lattice:\n    the dual (or reciprocal) of a lattice $\\mathcal L\\in\\mathbb R^n$ is defined as\n    $$\\mathcal L^*:=\\{w:\\langle w, \\mathcal L\\rangle\\subseteq\\mathbb Z \\},$$\nif $B$ is a basis of $\\mathcal L$, then $B^{-t}:=(B^t)^{-1}=(B^{-1})^t$ is a basis of $\\mathcal L^*$,\n    and $\\forall c\\in \\mathbb R, (c\\mathcal L)^*=c^{-1}\\mathcal L^*$\n\n\n### Computational Problems\nAll mentioned problems can be defined with respect to any norm, but the Euclidean norm $||x|| = \\sqrt{\\sum_i x^2}$ is the most common\n\n- Shortest Vector Problem (SVP)\n    given an arbitrary basis $B$ of some lattice $\\mathcal L=\\mathcal L(B)$, find $v\\in \\mathcal L$ for which $||v||=\\lambda_1(\\mathcal L)$\n    \n- Approximate Shortest Vector Problem (SVP$_\\gamma$)\n    $\\gamma=\\gamma(n)$ is a factor function $\\geq 1$ where n is the dimension of the lattice, find a nonzero vector $v\\in \\mathcal L$ for which $||v||\\leq\\gamma(n)\\cdot\\lambda_1(\\mathcal L).$\n    \n- Decisional Approximate SVP (GapSVP$_\\gamma$)\n    Given a basis $B$ of n-diemnsional lattice $\\mathcal L$, determine $\\mathcal L$ is either $\\lambda_1(\\mathcal L)\\leq 1$ or $\\lambda_1(\\mathcal L)> \\gamma(n)$\n    \n- Closest Vector Problem (CVP)\n    Givven a lattice basis $\\text B$ and a target vector $\\text t$ (not necessarily in the lattice), find the lattice point $\\text v\\in\\mathcal L(\\text B)$\n    \n- Shortest Independent Vectors Problem (SIVP)\n    Given a basis $B$ of full-rank n-dimensional lattice $\\mathcal L$ ouput $S = \\{s_i\\}\\subset \\mathcal L$ with n linearly independent lattice vector that $\\forall i, ||s_i||\\leq\\lambda_n(\\mathcal L)$\n    \n- Approximate Shortest Independent Vectors Problem (SIVP$_\\gamma$)\n    Given a basis $B$ of full-rank n-dimensional lattice $\\mathcal L$ ouput $S = \\{s_i\\}\\subset \\mathcal L$ with n linearly independent lattice vector that $\\forall i, ||s_i||\\leq\\gamma(n)\\cdot\\lambda_n(\\mathcal L)$\n    \n- Bounded Distance Decoding Problem (BDD$_\\gamma$)\n    Given a basis $B$ of an n-dimensional lattice $\\mathcal L$ and a target point $t\\in\\mathbb R^n$ with $dist(t, \\mathcal L)<d=\\lambda_1(\\mathcal L)/(2\\gamma(n))$ garanteed, find the unique lattice vector $v\\in\\mathcal L$ s.t. $||t-v||<d$\n\n### q-ary lattices\n\nlattices $\\mathcal L$ satisfying $q\\mathbb Z^n\\subseteq\\mathcal L\\subseteq\\mathbb Z^n$ for some integer(possibly prime) $q$\n- the membership of a vector $\\text x$ in $\\mathcal L$ is determined by $\\text x \\mod q$,\n- such lattices are in one-to-one correspondence with linear codes in $\\mathbb Z_q^n$\n- $\\forall \\mathcal L\\subseteq\\mathbb Z^n, \\mathcal L$ is a q-ary lattice for some $q$, which $q$ is an integer mutiple of $\\det(\\mathcal L)$\n- Given a matrix $\\text A\\in\\mathbb Z^{n\\times m}_q$ for some integers q, m, n, we can define two m-dimensional q-ary lattices\n    $$\\eqalign{\n        \\Lambda_q(\\text A) &=\\{\\text y\\in\\mathbb Z^m:\\text y=\\text A^T\\text s \\text { mod } q \\text{ for some }s\\in\\mathbb Z^n\\}\\\\\n        \\Lambda^\\bot_q(\\text A) &=\\{\\text y\\in\\mathbb Z^m:\\text{Ay}=0\\text{ mod q}\\}\n    }$$\n\n- the first q-ary lattice is generated by the rows of $\\text A$, e.g. it corresponds to the code generated by the rows of $\\text A$\n- the second q-ary lattice contains all vectors that are orthogonal modulo $q$ to the rows of $\\text A$, e.g. it corresponds to the code whose parity check matrix is $\\text A$\n- follows from the defination that first and second lattice are dual two each other, e.g., $\\Lambda^\\bot_q(\\text A)=q\\cdot \\Lambda_q(\\text A)^*$ and $\\Lambda_q(\\text A)=q\\cdot \\Lambda^\\bot_q(A)^*$\n\n### Finding Short Vectors in Random q-ary Lattices\nGiven a random matrix $\\text A\\in\\mathbb Z^{n\\times m}_q$ for some $q$, $n$, and $m\\geq n$ and we are asked to find a short vector in $\\Lambda^\\bot_q(\\text A)$\n- it's equivalent to asking for a short solution to a set of $n$ random equations modulo $q$ in $m$ variables\n- there will be two algorthim mentioned later\n\n#### estimate the length of the shortest nonzero vector\n- assume $q$ is prime\n- with high probability (with m is not too close to n), the rows of $\\text A$ are linearly independent over $\\mathbb Z_q$\n- In such case, the number of elements of $\\mathbb Z^m_q$ that belong to $\\Lambda^\\bot_q(\\text A)$ is exactly $q^{m-n}$\n- It follows that $\\det(\\Lambda^\\bot_q(A))=q^n$\n- We heuristically estimate $\\lambda_1(\\Lambda^\\bot_q(A))$ as the smallest radius of a ball whose volume is $q^n$, i.e. $\\lambda_1(\\Lambda^\\bot_q(A))\\approx q^{n/m}\\cdot ((m/2)!)^{1/m}/\\sqrt\\pi\\approx q^{n/m}\\cdot \\sqrt{\\frac{m}{2\\pi e}}$, which we use the formula for the volume of a ball in m dimensions\n- for resonable values of m (not too close to n nor too large), some experiments in low dimensions indicated this estimate to be very good.\n\n### Lattice reduction methods\n- the length of the vector obtained by running the best known algorithms on a random m-dimensional q-ary lattice $\\Lambda^\\bot_q(A)$ is close to $$\\min\\{q, (\\det(\\Lambda^\\bot_q(A)))^{1/m}\\cdot \\delta^m\\}=\\min\\{q, q^{n/m}\\delta^m\\}$$, the parameter $\\delta$ depends on the algorithm used. Faster algorithms provide $\\delta\\approx 1.013$ whereas slower and more precise algorithm provide $\\delta\\approx 1.012$ or even $\\delta\\approx 1.011$, Gama and Nguyen in fact estimate that a factor of 1.005 is totally out of reach in dimension 500\n- m's effect on the hardness of the question ![](https://hackmd.io/_uploads/r12VZObw3.png), this figure is $q^{n/m}\\delta^m$ with $\\delta=1.01$, $q=4416857$, and $n=100$. The minimum of the function is $2^{2\\sqrt{n\\log q\\log\\delta}}$, it means the sortest vectors are produced when $m=\\sqrt{n\\log q/\\log\\delta}$\n- So when consider the problem, reducing the dimension to desired m is really helpful on finding the shortest vector.\n- Combinatorial methods\n    given a matrix $A\\in \\mathbb Z^{n\\times m}_q$, we want to find a lattice point in $\\Lambda^\\bot_q(A)$ with cooridinates all bounded in absolute value by $b$\n    - Divide the columns of $A$ into $2^k$ groups (for some k to be determined)\n    - For each group, build a list containing all linear combinations of the columns with coefficients in $\\{-b, ..., b\\}$\n    - At this point we have $2^k$ list, each containing $L=(2b+1)^m/2^k$ vectors in $\\mathbb Z^n_q$\n    - Combining all list by pair:\n        $\\text x$ in first list, $\\text y$ in second list, take all $\\text x+\\text y$ that is zero in the first $\\log_q L$ coordinates\n    - Since the coordinate can take $q^{\\log_q L}=L$ values, we expect the merged list to $L\\cdot L/L=L$\n    - keep combining for k turn, then we get only one list of size $L$ containing vectors that are 0 in their first $k\\cdot \\log_qL$ coordinates, so we choose k s.t. $n\\approx (k+1)\\log_qL$, then we can expect the next turn get all zero vector\n    - cost:\n        The all zero vector found in the last list is given by a combination of the columns of A with coefficients bounded by b, so we have found the desired short lattice vector. Differently from lattice reduction, we can always expect this attack to succeed when A is random. The question is: what is the cost of running the attack? It is easy to see that the cost of the attack is dominated by the size of the lists L, which equals (2b + 1)m/2 k.\n\n## (Descrete) Gaussians and Subgaussians\n\n- Gaussians: for any $n\\in \\mathbb Z$ and real $s>0$, which $s$ is omitted if $s=1$, the Gaussian function $\\rho_s(\\text x):=e^{-\\pi (\\frac{||\\text x||}{s})^2} = \\rho(\\text x/s)$\n\n- Continuous Guassian distribution $D_s$ of parameter $s$ over $\\mathbb R^n$ is defined to have probability density function proportional to $\\rho_s$ i.e.\n    $$f(\\text x):=\\frac{\\rho_s(\\text x)}{\\int_{\\mathbb R^n}\\rho_s(\\text z)d\\text z}=\\rho_s(\\text x)/s^n$$\n    \n- discrete Gaussian probability distribution $D_{c+\\mathcal L, s}(\\text x)$:\n    $$D_{c+\\mathcal L, s}(\\text x)\\propto\n    \\left\\{\\begin{array}{r}\n    \\begin{align}\n        &\\rho_s(\\text x)    &{\\text{if x}\\in c+\\mathcal L}\\\\\n        &0                  &{\\text{otherwise.}}\n    \\end{align}\n    \\end{array}\\right.$$\n    \n- Smoothing parameter:\n    - define $\\rho_s(c+\\mathcal L):=\\sum_{\\text x\\in c+\\mathcal L}\\rho_s(\\text x)$\n    - smoothing parameter $\\eta_\\varepsilon(c+\\mathcal L)$ with tolerance $\\varepsilon>0$\n        $$\\eta_\\varepsilon(c+\\mathcal L):=min(\\forall_{s>0}, \\rho_{1/s}(\\mathcal L^*)\\leq1+\\varepsilon)$$\n    - theorem 2.3.1\n        $\\forall \\mathcal L\\subseteq \\mathbb R^n, \\eta_{2^{-n}}(\\mathcal L)\\leq\\sqrt n/\\lambda_1(\\mathcal L^*)$\n    - theorem 2.3.2\n        $\\forall \\mathcal L\\subseteq \\mathbb R^n$ and $\\varepsilon \\in (0, 1/2),$\n        $$\\eta_\\varepsilon(\\mathcal L)\\leq \\min_{basis \\text { B } of \\text { }\\mathcal L}||\\tilde {\\text B}||\\cdot \\sqrt{\\log O(n/\\varepsilon)}\\leq\\lambda_n(\\mathcal L)\\cdot \\sqrt{\\log O(n/\\varepsilon)}$$\n        where $||\\tilde {\\text B}||=\\max_i||\\tilde {\\text{b}_i}||$ denotes the maximal length of the Gram-Schmidt orthogonalized vector $\\{\\tilde{\\text b_i}\\}$ of the ordered basis $\\text B={\\text b_i}$\n\n    - Several works have shown that when $s\\geq\\eta(\\mathcal L)$, the discrete Guassion distribution $\\text D_{c+\\mathcal L, s}$, behaves very much like the continuous Gaussian $\\text D_s$ in many important respects. For example, their moments and tails are nearly the same, and the sum of independent discrete Gaussians is a discrete Gaussian.\n\n- Subgaussianity\n    a real random variable $X$ is subgaussian with parameter $s$ if for every $t\\geq 0$, $$\\Pr[|x|>t]\\leq 2e^{-\\pi \\frac{t^2}{s^2}}$$\n    more generally, a random vector $\\text x$ over $\\mathbb R^n$ is subgaussian with parameter $s$ if every marginal $\\langle \\text x, \\text u\\rangle$ is, for all unit vectors $\\text u\\in\\mathbb R^n$\n    - Examples with parameter s:\n        1. any symmetric random variable having magnitude bounded by $s/\\sqrt{2\\pi}$\n        2. the continuous Gaussian $D_s$ and discrete Gaussian $D_{\\mathcal L,s}$ over any lattice $\\mathcal L$\n        3. discrete Gaussian $D_{c+\\mathcal L,s}$ over any coset when $s\\geq \\eta(\\mathcal L)$ (under a slight relaxation of subgaussianity)\n\n## Cryptographic\n\n- security parameter $\\lambda$ relugate the running times of all algorithm. e.g. polynomial $\\lambda^{O(1)}$ running time for all algorithms, and that the attacker's advantage is negligible $\\lambda^{-\\omega(1)}$\n- Function Families\n    A function family is a function $f:K\\times X\\rightarrow Y$ where space $K$ for keys, $X$ for domain, and $Y$ for range, it is called family since the set of functions $f_k(\\cdot)=f(k,\\cdot)$ for keys $k\\in K$. if $|X|>|Y|$, i.e. the function \"compresses\" its input by some amount, it is often called hash function.\n    properties:\n    - one way family $f$\n        given $k\\in K, y=f_k(x)\\in Y$ where $k, x$ are randomly chosen from prescribed distributions, it is infeasible to find any preimage $x'\\in f_k^{-1}(y)$.\n    - collision resistant family f\n        given a random $k\\in K$ (chosen from a prescried distribution), it is infeasible to find distinct $x, x'\\in X$ such that $f_k(x)=f_k(x').$\n        \n- Public-Key Encryption (Asymmetric encryption scheme)\n    - An asymmetric encryption scheme consist of three randomized algorithms having following interfaces:\n        1. key generator\n            given the security parameter, ouputs a public key and secret key\n        2. encryption algorithm\n            takes the public key and a message (from some set of valid messages) and outputs a ciphertext\n        3. decryption algorithm\n            takes a secret key and a ciphertext, and outputs either a message or a distinguished \"failure\" symbol.\n        \n    \n    - semantic security, or indistingusiability under chosen-plaintext attack (IND-CPA) parameterized by a bit $b\\in \\{0, 1\\}$\n        1. Generate a public/secret key pair, and give the public key to the attacker, who must reply with two valid message $m_0, m_1$. (If the valid message space is just {0, 1}, then we may assume that $m_b=b$ without loss of generality.)\n        2. Encrypt $m_b$ using the public key and give the resulting \"challenge ciphertext\" to the attacker.\n        3. Finally, the attacker either accepts or rejects.\n\n        An encryption scheme is said to be semantically (or IND-CPA) secure if it is infeasible for an attacker to distinguish between two cases $b=0$ and $b=1$. That is, its probabilities of accepting in the two cases should differ by only a negligible amount.\n    - active security, or indistinguishability under chosen-ciphertest attack (IND-CCA)\n        give the attacker access to a decryption oracle, i.e., one that runs the decryption algorithm (with the secret key) with any ciphertext the attacker may query, except for the challenge ciphertext. The scheme is said to be actively (or IND-CCA) secure if it is infeasible for an attacker to distinguish between the two cases $b=0$ and $b=1$\n        \n## LWE(Learning With Error)-based cryptosystem\n- introduction\n    LWE-based system is perhaps the most efficient lattice-based cryptosystem to date supported by a theoretical proof of security.\n- naive construct complexity\n     When based on the hardness of lattice problems in dimension n, the cryptosystem has a public key of size $\\tilde{O}(n^2)$, requires $\\tilde O(n)$ bit operations per encrypted bit, and expands each encrypted bit to $O(1)$ bits.\n- parameter\n    This problem is parametrized by integers $n, m, q$ and a probility distribution $\\chi$ on $\\mathbb Z_q$, typically taken to be \"rounded\" normal distribution.\n- input\n    The input is a pair $(\\text A, \\text v)$ where $\\text A\\in \\mathbb Z^{m\\times n}_q$ is choosen uniformly, and $\\text v$ is either chosen uniformly from $\\mathbb Z^m_q$ or chosen to be $\\text{As}+\\text e$ for a uniformly chosen $\\text s\\in \\mathbb Z^n_q$ and a vector $\\text e\\in \\mathbb Z^m_q$ chosen according to $\\chi^m$\n- cryptosystem\n    It is parameterized by integers $n, m, \\ell, t, r, q$, and a real $\\alpha > 0$. n is in some sense the main security parameter.\n    - The message space is $\\mathbb Z^\\ell_t$. \n    - $f$ is the functions that maps the message space $\\mathbb Z^\\ell_t$ to $\\mathbb Z^\\ell_q$ by multiplying each coordinate by $q/t$ and rounded to nearest integer. $f^{-1}$ dividing each coordinate by $q/t$ and rounding to the nearest integer.\n- scheme\n    ![](https://hackmd.io/_uploads/SJNj6cZPn.png)\n- Decryption description\n    $$\\begin{split}\n    f^{-1}(\\text c-\\text S^T)&=f^{-1}(\\text P^T\\text a+f(\\text v)-\\text S^T\\text A^T\\text a)\\\\\n    &=f^{-1}((\\text A\\text S+\\text E)^T\\text a+f(\\text v)-\\text S^T\\text A^T\\text a)\\\\\n    &=f^{-1}(\\text E^T\\text a+f(\\text v))\n    \\end{split}$$\n- Decrypyion error\n    - in order for a letter decryption error to occur, say in the first letter, the first coordinate of $\\text E^T\\text a$ must be greater than $q/(2t)$ in absolute value.\n    - since the sum of independent normal variables is still a normal variable with the variance begin the sum of variances, Fixing the vector $\\text a$ and ignoring the rounding, the distribution of the first coordinate of $\\text E^T\\text a$ is a normal distribution with mean 0 and standard deviation $\\alpha q||a||/\\sqrt{2\\pi}$\n    - Now the norm of $\\text a$ can be seen to be with very high probability close to $$||a||\\approx\\sqrt{r(r+1)m/3}$$ by estimate the square expectation value $$\\frac 1{2r+1}\\sum^r_{k=-r}k^2=\\frac {r(r+1)}{3}$$\n    - $\\Phi$ is the cumulative distribution function of the standard normal distribution, then $$\\text{error probability per letter}\\approx 2\\Bigg(1-\\Phi\\Bigg(\\frac 1{2t\\alpha}\\cdot\\sqrt{\\frac{6\\pi}{r(r+1)m}}\\Bigg)\\Bigg)$$\n- final conclusion\n    ![](https://hackmd.io/_uploads/B1qjTs-Ph.png)\n    ![](https://hackmd.io/_uploads/BJ5rCjWvh.png)\n"
    }
]